#!/usr/bin/env node

import { promises as fs } from 'node:fs';
import path from 'node:path';
import { fileURLToPath } from 'node:url';
import { optimize } from 'svgo';

const __dirname = path.dirname(fileURLToPath(import.meta.url));
const ROOT_DIR = path.resolve(__dirname, '..');
const ICONS_SOURCE = path.join(ROOT_DIR, 'icons');
const OUTPUT_DIR = path.join(ROOT_DIR, 'projects', 'icons-angular', 'src', 'lib');
const GENERATED_DIR = path.join(OUTPUT_DIR, 'generated');
const MANIFEST_TS_PATH = path.join(GENERATED_DIR, 'icon-manifest.ts');
const MANIFEST_JSON_PATH = path.join(GENERATED_DIR, 'icon-manifest.json');

const SVGO_CONFIG = {
  multipass: true,
  plugins: [
    'preset-default',
    {
      name: 'removeAttrs',
      params: {
        attrs: '(data-name)',
      },
    },
    {
      name: 'removeDimensions',
      active: true,
    },
  ],
};

const ensureDirectory = async (directoryPath) => {
  await fs.mkdir(directoryPath, { recursive: true });
};

const readVariants = async () => {
  try {
    const entries = await fs.readdir(ICONS_SOURCE, { withFileTypes: true });
    return entries.filter((entry) => entry.isDirectory()).map((entry) => entry.name);
  } catch (error) {
    throw new Error(`The icons directory "${ICONS_SOURCE}" could not be read. Ensure it exists and contains variant folders.\n${error.message}`);
  }
};

const escapeForSingleQuotes = (value) => value.replace(/\\/g, '\\\\').replace(/'/g, "\\'").replace(/\r?\n/g, '');

const buildManifestEntry = (name, variant, svgText) => ({
  name,
  variant,
  source: {
    svgText,
  },
});

const readAndOptimizeIcon = async (filePath) => {
  const rawContent = await fs.readFile(filePath, 'utf8');
  const optimized = optimize(rawContent, {
    path: filePath,
    ...SVGO_CONFIG,
  });

  if (optimized.error) {
    throw new Error(`SVGO failed for ${filePath}: ${optimized.error}`);
  }

  if (!optimized.data.includes('viewBox')) {
    throw new Error(`Icon "${filePath}" is missing a "viewBox" attribute. Please ensure scalable icons before publishing.`);
  }

  await fs.writeFile(filePath, optimized.data, 'utf8');
  return optimized.data;
};

const writeManifestFiles = async (manifestEntries) => {
  await ensureDirectory(GENERATED_DIR);

  const manifestObject = {
    generatedAt: new Date().toISOString(),
    count: manifestEntries.length,
    icons: manifestEntries,
  };

  await fs.writeFile(MANIFEST_JSON_PATH, JSON.stringify(manifestObject, null, 2));

  const manifestTsEntries = manifestEntries
    .map((entry) => {
      const lines = [
        '  {',
        `    name: '${escapeForSingleQuotes(entry.name)}',`,
      ];

      if (entry.variant) {
        lines.push(`    variant: '${escapeForSingleQuotes(entry.variant)}',`);
      }

      lines.push(`    source: { svgText: ${JSON.stringify(entry.source.svgText)} },`);
      lines.push('  }');
      return lines.join('\n');
    })
    .join(',\n');

  const manifestTsContent = `/* eslint-disable */
/* istanbul ignore file */
// Auto-generated by tools/generate-icons-manifest.mjs. Do not edit manually.

import { IconRegistration } from '../icon.types';

export const WB_ICON_MANIFEST: IconRegistration[] = [
${manifestTsEntries}
];
`;

  await fs.writeFile(MANIFEST_TS_PATH, manifestTsContent);
};

const createManifest = async () => {
  const variants = await readVariants();

  if (variants.length === 0) {
    console.warn('No variants were found within the icons directory. Manifest generation skipped.');
    return;
  }

  const manifestEntries = [];

  for (const variant of variants) {
    const variantDir = path.join(ICONS_SOURCE, variant);
    const files = await fs.readdir(variantDir);
    const svgFiles = files.filter((file) => file.endsWith('.svg'));

    for (const svgFile of svgFiles) {
      const iconName = path.basename(svgFile, '.svg');
      const filePath = path.join(variantDir, svgFile);
      const svgText = await readAndOptimizeIcon(filePath);
      manifestEntries.push(buildManifestEntry(iconName, variant, svgText));
    }
  }

  await writeManifestFiles(manifestEntries);
  console.log(`Generated manifest for ${manifestEntries.length} icons across ${new Set(manifestEntries.map((icon) => icon.variant)).size} variants.`);
};

createManifest().catch((error) => {
  console.error(error);
  process.exitCode = 1;
});


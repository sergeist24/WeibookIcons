#!/usr/bin/env node

import { promises as fs } from 'node:fs';
import path from 'node:path';
import { fileURLToPath } from 'node:url';
import { optimize } from 'svgo';
import { execSync } from 'child_process';

const __dirname = path.dirname(fileURLToPath(import.meta.url));
const ROOT_DIR = path.resolve(__dirname, '..');
const ICONS_SOURCE = path.join(ROOT_DIR, 'icons');
const OUTPUT_DIR = path.join(ROOT_DIR, 'projects', 'icons-angular', 'src', 'lib');
const GENERATED_DIR = path.join(OUTPUT_DIR, 'generated');
const MANIFEST_TS_PATH = path.join(GENERATED_DIR, 'icon-manifest.ts');
const MANIFEST_JSON_PATH = path.join(GENERATED_DIR, 'icon-manifest.json');

const SVGO_CONFIG = {
  multipass: true,
  plugins: [
    'preset-default',
    {
      name: 'removeAttrs',
      params: {
        attrs: '(data-name)',
      },
    },
    {
      name: 'removeDimensions',
      active: true,
    },
  ],
};

// Colores para la consola
const colors = {
  reset: '\x1b[0m',
  bright: '\x1b[1m',
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  blue: '\x1b[36m',
  red: '\x1b[31m',
};

const log = {
  info: (msg) => console.log(`${colors.blue}‚Ñπ${colors.reset} ${msg}`),
  success: (msg) => console.log(`${colors.green}‚úì${colors.reset} ${msg}`),
  warn: (msg) => console.log(`${colors.yellow}‚ö†${colors.reset} ${msg}`),
  error: (msg) => console.error(`${colors.red}‚úó${colors.reset} ${msg}`),
  title: (msg) => console.log(`\n${colors.bright}${msg}${colors.reset}\n`),
};

const ensureDirectory = async (directoryPath) => {
  await fs.mkdir(directoryPath, { recursive: true });
};

const readVariants = async () => {
  try {
    const entries = await fs.readdir(ICONS_SOURCE, { withFileTypes: true });
    return entries.filter((entry) => entry.isDirectory()).map((entry) => entry.name);
  } catch (error) {
    throw new Error(`The icons directory "${ICONS_SOURCE}" could not be read. Ensure it exists and contains variant folders.\n${error.message}`);
  }
};

const escapeForSingleQuotes = (value) => value.replace(/\\/g, '\\\\').replace(/'/g, "\\'").replace(/\r?\n/g, '');

const buildManifestEntry = (name, variant, svgText) => ({
  name,
  variant,
  source: {
    svgText,
  },
});

const readAndOptimizeIcon = async (filePath, options = {}) => {
  const { dryRun = false } = options;
  const rawContent = await fs.readFile(filePath, 'utf8');
  const optimized = optimize(rawContent, {
    path: filePath,
    ...SVGO_CONFIG,
  });

  if (optimized.error) {
    throw new Error(`SVGO failed for ${filePath}: ${optimized.error}`);
  }

  if (!optimized.data.includes('viewBox')) {
    throw new Error(`Icon "${filePath}" is missing a "viewBox" attribute. Please ensure scalable icons before publishing.`);
  }

  if (!dryRun) {
    await fs.writeFile(filePath, optimized.data, 'utf8');
  }

  return optimized.data;
};

const writeManifestFiles = async (manifestEntries) => {
  await ensureDirectory(GENERATED_DIR);

  const manifestObject = {
    generatedAt: new Date().toISOString(),
    count: manifestEntries.length,
    icons: manifestEntries,
  };

  await fs.writeFile(MANIFEST_JSON_PATH, JSON.stringify(manifestObject, null, 2));

  const manifestTsEntries = manifestEntries
    .map((entry) => {
      const lines = [
        '  {',
        `    name: '${escapeForSingleQuotes(entry.name)}',`,
      ];

      if (entry.variant) {
        lines.push(`    variant: '${escapeForSingleQuotes(entry.variant)}',`);
      }

      lines.push(`    source: { svgText: ${JSON.stringify(entry.source.svgText)} },`);
      lines.push('  }');
      return lines.join('\n');
    })
    .join(',\n');

  const manifestTsContent = `/* eslint-disable */
/* istanbul ignore file */
// Auto-generated by tools/cli.mjs. Do not edit manually.

import { IconRegistration } from '../icon.types';

export const WB_ICON_MANIFEST: IconRegistration[] = [
${manifestTsEntries}
];
`;

  await fs.writeFile(MANIFEST_TS_PATH, manifestTsContent);
};

const generateManifest = async (options = {}) => {
  const { dryRun = false, verbose = false } = options;
  
  log.title('üì¶ Generando Manifest de Iconos');
  
  const variants = await readVariants();

  if (variants.length === 0) {
    log.warn('No variants were found within the icons directory. Manifest generation skipped.');
    return;
  }

  log.info(`Encontradas ${variants.length} variantes: ${variants.join(', ')}`);

  const manifestEntries = [];
  let processedCount = 0;
  let errorCount = 0;

  for (const variant of variants) {
    const variantDir = path.join(ICONS_SOURCE, variant);
    const files = await fs.readdir(variantDir);
    const svgFiles = files.filter((file) => file.endsWith('.svg'));

    if (verbose) {
      log.info(`Procesando variante "${variant}" (${svgFiles.length} iconos)`);
    }

    for (const svgFile of svgFiles) {
      try {
        const iconName = path.basename(svgFile, '.svg');
        const filePath = path.join(variantDir, svgFile);
        
        if (verbose) {
          log.info(`  - ${iconName}`);
        }
        
        const svgText = await readAndOptimizeIcon(filePath, { dryRun });
        manifestEntries.push(buildManifestEntry(iconName, variant, svgText));
        processedCount++;
      } catch (error) {
        errorCount++;
        log.error(`Error procesando ${svgFile}: ${error.message}`);
      }
    }
  }

  if (!dryRun) {
    await writeManifestFiles(manifestEntries);
  }

  const variantCount = new Set(manifestEntries.map((icon) => icon.variant)).size;
  
  if (errorCount > 0) {
    log.warn(`Completado con ${errorCount} error(es)`);
  } else {
    log.success(`Manifest generado exitosamente`);
  }
  
  console.log(`  ‚Ä¢ ${manifestEntries.length} iconos procesados`);
  console.log(`  ‚Ä¢ ${variantCount} variantes`);
  console.log(`  ‚Ä¢ ${processedCount} iconos optimizados`);
  
  if (dryRun) {
    log.info('Modo dry-run: No se realizaron cambios en los archivos');
  }
};

const validateIcons = async () => {
  log.title('üîç Validando Iconos');
  
  const variants = await readVariants();
  const issues = [];
  let totalIcons = 0;

  for (const variant of variants) {
    const variantDir = path.join(ICONS_SOURCE, variant);
    const files = await fs.readdir(variantDir);
    const svgFiles = files.filter((file) => file.endsWith('.svg'));

    for (const svgFile of svgFiles) {
      totalIcons++;
      const iconName = path.basename(svgFile, '.svg');
      const filePath = path.join(variantDir, svgFile);

      try {
        const content = await fs.readFile(filePath, 'utf8');
        
        // Validar viewBox
        if (!content.includes('viewBox')) {
          issues.push({
            type: 'missing-viewbox',
            variant,
            icon: iconName,
            message: 'Falta atributo viewBox',
          });
        }

        // Validar que sea SVG v√°lido
        if (!content.includes('<svg')) {
          issues.push({
            type: 'invalid-svg',
            variant,
            icon: iconName,
            message: 'No es un archivo SVG v√°lido',
          });
        }

        // Validar nombres de archivo
        if (!/^[a-z0-9-]+$/.test(iconName)) {
          issues.push({
            type: 'invalid-name',
            variant,
            icon: iconName,
            message: 'El nombre contiene caracteres inv√°lidos (solo a-z, 0-9, -)',
          });
        }
      } catch (error) {
        issues.push({
          type: 'read-error',
          variant,
          icon: iconName,
          message: error.message,
        });
      }
    }
  }

  if (issues.length === 0) {
    log.success(`Todos los iconos son v√°lidos (${totalIcons} iconos verificados)`);
  } else {
    log.error(`Se encontraron ${issues.length} problema(s):`);
    issues.forEach((issue) => {
      console.log(`  ‚Ä¢ ${issue.variant}/${issue.icon}: ${issue.message}`);
    });
    process.exitCode = 1;
  }
};

const showStats = async () => {
  log.title('üìä Estad√≠sticas de Iconos');
  
  const variants = await readVariants();
  const stats = {
    variants: {},
    total: 0,
  };

  for (const variant of variants) {
    const variantDir = path.join(ICONS_SOURCE, variant);
    const files = await fs.readdir(variantDir);
    const svgFiles = files.filter((file) => file.endsWith('.svg'));
    stats.variants[variant] = svgFiles.length;
    stats.total += svgFiles.length;
  }

  console.log(`Total de iconos: ${colors.bright}${stats.total}${colors.reset}`);
  console.log(`Variantes: ${variants.length}`);
  console.log('\nPor variante:');
  Object.entries(stats.variants).forEach(([variant, count]) => {
    console.log(`  ‚Ä¢ ${variant}: ${count} iconos`);
  });
};

const optimizeIcons = async (options = {}) => {
  const { verbose = false } = options;
  
  log.title('‚ö° Optimizando Iconos');
  
  const variants = await readVariants();
  let optimizedCount = 0;
  let errorCount = 0;

  for (const variant of variants) {
    const variantDir = path.join(ICONS_SOURCE, variant);
    const files = await fs.readdir(variantDir);
    const svgFiles = files.filter((file) => file.endsWith('.svg'));

    for (const svgFile of svgFiles) {
      try {
        const filePath = path.join(variantDir, svgFile);
        await readAndOptimizeIcon(filePath);
        optimizedCount++;
        if (verbose) {
          log.success(`Optimizado: ${variant}/${svgFile}`);
        }
      } catch (error) {
        errorCount++;
        log.error(`Error optimizando ${svgFile}: ${error.message}`);
      }
    }
  }

  log.success(`Optimizaci√≥n completada: ${optimizedCount} iconos`);
  if (errorCount > 0) {
    log.warn(`${errorCount} error(es) durante la optimizaci√≥n`);
  }
};

// Parsear argumentos de l√≠nea de comandos
const args = process.argv.slice(2);
const command = args[0];

const commands = {
  generate: () => generateManifest({ verbose: args.includes('--verbose') || args.includes('-v') }),
  validate: () => validateIcons(),
  stats: () => showStats(),
  optimize: () => optimizeIcons({ verbose: args.includes('--verbose') || args.includes('-v') }),
  build: async () => {
    await generateManifest();
    log.info('Compilando librer√≠a...');
    try {
      execSync('ng build icons-angular', { stdio: 'inherit', cwd: ROOT_DIR });
      log.success('Build completado exitosamente');
    } catch (error) {
      log.error('Error durante el build');
      process.exitCode = 1;
    }
  },
  help: () => {
    console.log(`
${colors.bright}Weibook Icons CLI${colors.reset}

Comandos disponibles:

  ${colors.green}generate${colors.reset}     Genera el manifest de iconos
  ${colors.green}validate${colors.reset}     Valida todos los iconos
  ${colors.green}stats${colors.reset}        Muestra estad√≠sticas de iconos
  ${colors.green}optimize${colors.reset}     Optimiza todos los iconos SVG
  ${colors.green}build${colors.reset}        Genera manifest y compila la librer√≠a

Opciones:
  --verbose, -v    Muestra informaci√≥n detallada

Ejemplos:
  npm run icons:cli generate
  npm run icons:cli validate
  npm run icons:cli stats
  npm run icons:cli optimize --verbose
  npm run icons:cli build
`);
  },
};

if (!command || !commands[command]) {
  commands.help();
  process.exitCode = command ? 1 : 0;
} else {
  const result = commands[command]();
  if (result && typeof result.catch === 'function') {
    result.catch((error) => {
      log.error(error.message);
      process.exitCode = 1;
    });
  }
}

